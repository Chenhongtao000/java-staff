1、servlet执行流程
客户端发出http请求，web服务器将请求转发到servlet容器，servlet容器解析url并根据web.xml找到相对应的servlet，并将request、response对象传递给
找到的servlet，servlet根据request就可以知道是谁发出的请求，请求信息及其他信息，当servlet处理完业务逻辑后会将信息放入到response并响应到客
户端。

2、springMVC的执行流程
springMVC是由dispatchservlet为核心的分层控制框架。首先客户端发出一个请求web服务器解析请求url并去匹配dispatchservlet的映射url，如果匹配上
就将这个请求放入到dispatchservlet，dispatchservlet根据mapping映射配置去寻找相对应的handel，然后把处理权交给找到的handel，handel封装了处理
业务逻辑的代码，当handel处理完后会返回一个逻辑视图modelandview给dispatchservlet，此时的modelandview是一个逻辑视图不是一个正式视图，所以
dispatchservlet会通过viewresource视图资源去解析modelandview，然后将解析后的参数放到view中返回到客户端并展现。


重点知识
      
       JVM内存管理机制和垃圾回收机制（基本每次面试都会问，一定要搞得透彻）

       JVM内存调优（了解是怎么回事，一般做项目过程中使用较多）

       设计模式（熟悉常见设计模式的应用场景，会画类图，实在不行背几个也是有用的）

       多线程（每次都会问，包括线程和进程、线程状态、线程并发的操作等，需要深入复习）

       JAVA集合类框架（理解框架图、HashMap、ArrayList、HashSet等的关系和区别，其中HashMap的存储机制几乎每次都有问 ）
                      (Vector和Hashtable、Collections.synchronizedXxx()同步容器 VS java.util.concurrent包并发容器 ConcurrentHashMap...)
       JAVA的异常处理机制（异常的分类、常见的异常有哪些、Try catch finally的使用）

       JVM运行机制（理解JVM是如何运行的）

       Linux基础（面试笔试中对linux也有一定的要求，建议最好搭建一个linux虚拟机，并练习常用的命令）


数据结构和算法
     常见的排序算法就不说了，需要理解其原理和会写代码，还有时间空间复杂度也要知道

     队列、栈：需要理解其存取结构，并能在某些场景下使用

     二叉树：树的遍历、树的深度、按层次输出、平衡二叉树、逆序打印树等

     链表：逆序、合并两有序的链表、判断链表是否又环、链表倒数第K个元素等

     字符串：KMP算法、动态规划（这个是重点，需要好好理解动态规划，常见的题有：求解最长回文子串、求解最长公共子串等）
     海量数据处理：现在好多大公司都会问海量数据的处理，所以需要掌握常见的处理方法，比如Bit-map、分而治之、hash映射等，可以百度看看相关的文章，加深理解

 

数据库相关（数据库是重点，每家公司都会问）
     最基本的数据库CRUD操作要熟悉，能够根据表写出需要的SQL语句

     事务、零时表、索引、表锁、行列锁、视图、存储过程等都要深入理解

     互联网公司处理的数据量都很大，所以有必要对数据库优化和大数据的处理进行了解和熟悉

     建议看看Nosql和redis等非关系数据库相关的书籍和资料

动态代理机制
	动态代理可以提供对另一个对象的访问，同时隐藏实际对象的具体事实。代理一般会实现它所表示的实际对象的接口。代理可以访问实际对象，但是延
	迟实现实际对象的部分功能，实际对象实现系统的实际功能，代理对象对客户隐藏了实际对象。客户不知道它是与代理打交道还是与实际对象打交道。
	动态代理主要包含以下角色：动态代理类（以下简称为代理类）是一个实现在创建类时在运行时指定的接口列表的类，该类具有下面描述的行为。代理
	接口 是代理类实现的一个接口。代理实例 是代理类的一个实例。每个代理实例都有一个关联的调用处理程序 对象，它可以实现接口 
	InvocationHandler。通过其中一个代理接口的代理实例上的方法调用将被指派到实例的调用处理程序的 Invoke 
	方法，并传递代理实例、识别调用方法的java.lang.reflect.Method 对象以及包含参数的 Object 
	类型的数组。调用处理程序以适当的方式处理编码的方法调用，并且它返回的结果将作为代理实例上方法调用的结果返回。

